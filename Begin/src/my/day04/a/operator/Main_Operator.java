package my.day04.a.operator;

public class Main_Operator {

	public static void main(String[] args) {
		// ~~~~~~~~~ 연산자 ~~~~~~~~~~~ //
		
				// #### 1. 산술연산자 ####
				//      +  -  *  /  %(나머지)   <<    >>    >>> 
				
				/*
				     x << n  은 x*(2의 n승)의 결과값과 같다. x는 실수형은 불가하고 정수형만 가능함.
				     x >> n  은 x가 양수일 경우 x/(2의 n승)의 결과값과 같다. x는 실수형은 불가하고 정수형만 가능함. 
				     x >>> n 은 정수 x를 32bit 형태의 2진수로 나타낸후 오른쪽으로 n번 이동시키고 빈자리는 0으로 채운다.
				 */
				
				System.out.println("==== 1. 산술연산자  +  -  *  /  %(나머지)   <<    >>    >>> ====");
				
				int n = 10;
				System.out.println("n+3 = " + (n+3) );  // n+3 = 13
				System.out.println("n-3 = " + (n-3) );  // n-3 = 7
				System.out.println("n*3 = " + (n*3) );  // n*3 = 30
				System.out.println("n/3 = " + (n/3) );  // n/3 = 3    정수/정수=정수(몫)
				System.out.println("n%3 = " + (n%3) );  // n%3 = 1    10 을 3 으로 나누었을때의 나머지 
				
				System.out.println("n<<3 = " + (n<<3)); // n<<3 = 80
				/*
			    int 는 4byte 이므로 32bit 로 구성된다.
			    10<<3 은 정수 10 을 이진수인 00000000 00000000 00000000 00001010 으로 나타내고
			    왼쪽방향으로 3개를 밀어버린다. 그러면 00000 00000000 00000000 00001010___ 이 되는데
			    그런 다음에 _ 자리에 0 으로 채운다. 
			    즉, 00000 00000000 00000000 00001010000 이 된다.
			    이진수 00000000000000000000000000001010000 을 십진수로 나타내면
			    1*(2의6승)+1*(2의4승)
			    64+16=80이 된다.
			    
			    즉, 10<<3 은 10*(2의3승) ==> 10*8 ==> 80 와 같은 것이 된다.				    
			*/
				System.out.println("n>>2 =" + (n>>2));	// n>>2 = 2
				/*
			    int 는 4byte 이므로 32bit 로 구성된다.
			    10<<2 은 정수 10 을 이진수인 00000000 00000000 00000000 00001010 으로 나타내고
			    오른쪽으로 2개를 밀어버린다. 그러면 __00000 00000000 00000000 000010 이 되는데
			    그런 다음에 _ 자리에는 정수 10의 최상위 부호비트(가장 왼쪽 비트1개, 양수이면 0 이고 음수이면 1 이다.)와 같은 값으로 나타낸다. 
			    즉, 0000000 00000000 00000000 000010 이 된다.
			    이진수 00000000000000000000000000010  을 십진수로 나타내면
			    1*(2의1승) ==> 1*2 ==> 2
			    2가 된다.
			    
			    즉, 10<<3 은 10*(2의3승) ==> 10*8 ==> 80 와 같은 것이 된다.				    
			*/
				System.out.println("n>>3 = " + (n>>>3));
				/*
			    int 는 4byte 이므로 32bit 로 구성된다.
			    10<<2 은 정수 10 을 이진수인 00000000 00000000 00000000 00001010 으로 나타내고
			    오른쪽으로 3개를 밀어버린다. 그러면 ___00000000 00000000 00000000 00001 이 되는데
			    그런 다음에 _ 자리에는 0으로 채운다.
			    즉, 0000000000 00000000 00000000 00001 이 된다.
			    이진수 00000000000000000000000000001  을 십진수로 나타내면
			    1*(2의0승) ==> 1*1 ==> 1이 된다.
				
				*/
				n = -10;
				System.out.println("~~~ n이 -10 인 경우 ~~~");
				/*
				 	>>> -10을 bit로 나타내어 주는 방법 <<<
				 	
				 	int 는 4 byte 이므로 32bit로 구성된다.
				 	컴퓨터의 음수 표현 방법은 2의 보수 표현 방법을 사용한다.
				 	2의 보수란? 1의 보수(0은 1로, 1은 0로 바꿔주는 것)로 변환한 후 +1 해주는 것이다.
				 	
				 	-10 을 이진수로 표현하면 다음과 같다.
				 	우선 10 을 이진수로 나타내면  00000000 00000000 00000000 00001010 인데
				 	이것을 1의 보수로 만든다. 즉, 11111111 11111111 11111111 11110101 이다.
				 	여기에 +1을 하면           11111111 11111111 11111111 11110110 이 된다.
				 	
				 	11111111 11111111 11111111 11110110 를 십진수로 나타내어 보면,
				 	첫번째 bit는 부호비트로 사용되어지는데
				 		0은 +임(양수)를 의미하고,
				 		1은 -임(음수)를 의미한다.
				 		
				 		첫번째 bit가 1인 경우,즉 음수를 뜻할 경우에는 아래와 같이 구한다.
				 		똑같은 1이 나오는 것 중에서 마지막 1만 취하고, 여기에다가 그 나머지를 끝까지 취한다.
				 		10110
				 		첫번째 값만 -를 붙이고, 그 나머지 값은 +로 연산을 하면 된다.
				 		-1*(2의 4승) + 0*(2의 3승) + 1*(2의 2승) + 1*(2의 1승) + 0*(2의 0승)
				 		-16 + 0 + 4 + 2 + 0 ==> -10	
				 */
				
				System.out.println("n<<3 =" + (n<<3));	//n<<3 -80
				/*
				    int 는 4byte 이므로 32bit 로 구성된다.
				    
				    -10을 이진수로 표현하면 다음과 같다.
				    11111111 11111111 11111111 11110110 이 된다.
				    
				    왼쪽방향으로 3개를 밀어버린다. 그러면 11111 11111111 11111111 11110110___ 이 되는데
				    그런 다음에 _ 자리에 0 으로 채운다. 
				    즉, 11111 11111111 11111111 11110110000 이 된다.
				    이진수 11111 11111111 11111111 11110110000 을 십진수로 나타내면
				    음수 이므로 10110000을 가져와서
				    -1* (2의 7승) + 1*(2의 5승) + 1*(2의 4승) 
				    -128 + 32 + 16 = -80이 된다.
				    
				    즉, -10<<3 은 -10*(2의3승) ==> -10*8 ==> -80 와 같은 것이 된다.				    
				*/
				System.out.println("n>>2 =" + (n>>2));	// n>>2 = 2
				/*
				  -10을 이진수로 표현하면 다음과 같다.
				   11111111 11111111 11111111 11110110 이 된다.
				    
				   이것을 오른쪽방향으로 2개를 밀어버린다.
				   즉, __11111111 11111111 11111111 111101
				   그런 다음에 _ 자리에는 정수 10의 최상위 부호비트(가장 왼쪽 비트1개, 양수이면 0 이고 음수이면 1 이다.)와 같은 값으로 나타낸다.
				   즉, 1로 채우므로
				   1111111111 11111111 11111111 111101
				   음수이므로 101을 가져와서
				   -1*(2의 2승) + 1*(2의 0승)
				   -4 + 1
				   -3
		
			    
			    즉, -10<<2 은 -10/(2의2승) ==> -10/4 ==> -3 와 같은 것이 된다.				    
			*/
			
				
				//#### 2. 증감연산자 ####
				// 		++ --
				
		System.out.println("==== 2. 증감연산자  ++  -- ====");
		
		//int a=7;
		//int b=3;
		//또는
		
		int a=7, b=3;
		
		System.out.println("a => " + a); // a => 7
		
		//a = a+1;
		//또는
		a++;
		
		System.out.println("a => " + a); // a => 8
	
		++a;
		System.out.println("a => " + a); // a => 9
		
		//b = b-1;
		//또는
		
		System.out.println("b => " + b); // b => 3
		b--;
		System.out.println("b => " + b); // b => 2
		
		--b;
		System.out.println("b => " + b); // b => 1
	
		// !!!! 꼭 암기하세요 !!!! //
		// 후위증감연산자(a++; b--;) 는 다른 연산을 다 마친 이후에 1씩 증감ㅎㄴ다.
		// 전위증감연산자(++a; --b;) 는 맨먼저 1씩 증감을 마친 이후에 다른 연산을 한다.
		int x=10, y=10;
		int z=++x; // ++x; x=x+1; x=11; z=x; z=11;
		System.out.println("z => "+ z); // z => 11
		System.out.println("x => "+ x); // x => 11
		
		z=y++; // z=y; z=10; y++; y=y+1; y=11
		System.out.println("z =>" + z); // z => 10
		System.out.println("y =>" + y); // y => 11
		
				//#### 3. bit 별 not 연산자 ####
				// 		~
			
		System.out.println("\n==== 3. bit 별 not 연산자 ~ ====");
		/*
		  주어진 정수값으 32bit 형태의 2진수로 바꾸어서 나타내는데
		  0 bit는 1 bit로 바꾸고, 1 bit는 0 bit로 바꾸어주는 것이다.		  	
		 */
		int m = 42;
		System.out.println("~m :" + ~m); // ~m :
		/*
		 00000000 00000000 00000000 00101010 <=== 42
		 11111111 11111111 11111111 11010101 <=== ~42
		 
		 첫번째 bit는 부호비트로 사용되어지는데
		 0은 +임(양수)를 의미하고,
		 1은 -임(음수)를 의미한다.
		 
		 1010101
		 첫번째 값만 -를 붙이고, 나머지 값은 +로 연산을 하면 된다.
		 -1*(2의 6승) + 1*(2의 4승) + 1*(2의 2승) + 1*(2의 0승)
		 -64 + 16 + 4 + 1 ==> -43
		 */
		
				//#### 4.논리 부정 연산자 ####
				// 		!
				
		System.out.println("\n==== 4. 논리 부정 연산자 ! ====");
		boolean bool = false;
		System.out.println("bool : "+ bool); // bool :false
		System.out.println("!bool : " + !bool);// !bool : true
	
		
		//#### 5. bit 연산자 ####
		//		& | ^
		System.out.println("\n==== 5. bit 연산자 & | ^ ====");
		/*
		  & (and 연산자) => 2개 bit 모두 1 일때만 1, 나머지는 0 
	      | (or 연산자)  => 2개 bit 중에서 적어도 1개가 1이면 1, 모두 0이어야만 0 
         ^ (xor 연산자) => 2개 bit 중에서 서로 달라야만 1, 같으면 0 	             
         & | ^ 연산자는 연산되어지는 대상이 정수일때만 사용가능함.  
		 */
		
		int x1=3, y1=5;
		System.out.println("x1 & y1 =>" + (x1 & y1)); // x1 & y1 => 1
		/*
		 		00000011  <== 3
		 	&	00000101  <== 5
		 		--------
		 		00000001 <== 1
		 */
		System.out.println("x1 | y1 =>" + (x1 | y1)); // x1 | y1 => 7
		/*
		 		00000011  <== 3
		 	|	00000101  <== 5
		 		--------
		 		00000111 <== 7
		 */
		System.out.println("x1 ^ y1 =>" + (x1 ^ y1)); // x1 ^ y1 => 6
		/*
		 		00000011  <== 3
		 	^	00000101  <== 5
		 		--------
		 		00000110 <== 6
		 */
					//#### 6.논리 연산자 ####
					// 	& | && ||
					
		System.out.println("\n==== 6. 논리 연산자 & | && || ====");
		/*
		수학에서는  T ∧  T ∧  F ==> F  
	            수학에서는  T ∧  T ∧  T ==> T
	            
	            수학에서는  T ∨  T ∨  F ==> T 
	            수학에서는  T ∨  T ∨  T ==> T 
	            수학에서는  F ∨  F ∨  F ==> F 
		*/
		
		int c=50, d=60, e=70;
		
		bool = (c>d) && (d<e) && (c ==3);
			//false && 스킵
		System.out.println("bool =>" + bool); // bool => false
		
		//수학에서는  F ∨  F ∨  F ==> F
		
		bool = (c>d) || (d<e) || (c ==3);
		
		System.out.println("bool =>" + bool); // bool => true
		
		System.out.println("\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
		
		bool = (c>d) & (d<e) & (c ==3);
		// false & true & false
		System.out.println("bool =>" + bool); // bool => false
			
		bool = (c>d) | (d<e) | (c ==3);
			//// false | true | false
		
		
		System.out.println("bool =>" + bool); // bool => true
		
		System.out.println("\n~~~~~~~~~~~~~~~~~~퀴즈~~~~~~~~~~~~~~~~~~~~~~~\n");
		
		int i=1;
		int j=i++; // j=i; j=1; i++; i=2;
		
		if( (i > ++j) & (i++ == j)) {
			i = i+j;
		}
		System.out.println("i ="+i); // i=3
		
		i=1;
		j=i++;
		
		if((i > ++j) && (i++ ==j)){
			i = i+j;
		}
		
		System.out.println("i="+i); // i=2
		
		System.out.println("\n~~~~~~~~~~~~~~~~~~퀴즈2~~~~~~~~~~~~~~~~~~~~~~\n");
		
		int m1= 41;
		int n1= 1;
		
		if ((m1++ == 0) | (n1++ ==2)) {
			m1 = 42;
		}
		System.out.println("m1 => "+m1+", n1 =>"+n1);
		// m1 => 42,   n1 =>2
		
		m1=0;
		n1=1;
		if((m1++ ==0)||(n1++ ==2)) {
			m1=42;
		}
		System.out.println("m1 => "+m1+" , n1 =>"+n1);
		//m1 =>42 , n1 =>1
		
		
		//#### 7.비교 연산자 ####
		// 	== 같다, != 같지않다, > < >= <=
		
		System.out.println("\n==== 7. 비교 연산자 == 같다, != 같지않다, > < >= <= ====");
		
		//#### 8.할당 연산자 ####
		// 	+= -= *= /= %=
				
		System.out.println("\n#### 8. 할당 연산자(연산후 대입 연산자) ####");
		// += -= *= /= %=
		
		int no = 1;
		no += 3; // no = no + 3; 와 같은것이다.
		System.out.println("no="+no); //no=4
		
		no -= 2; // no = no - 2; 와 같은것이다.
		System.out.println("no="+no); // no=2;
		
		no *= 5; // no = no * 5; 와 같은것이다.
		System.out.println("no="+no); // no=10;
		
		no /= 4; // no = no / 4; 와 같은것이다.
		System.out.println("no="+no); // no=2;
		
		no %= 3; // no = no % 3; 와 같은것이다.
		System.out.println("no="+no); // no=0;
		
		//#### 9.삼항 연산자 ####
		/*
		  	변수선언 = (조건식)?값1:값2;
		  	변수를 선언하고나서 값을 부여하고자 할 때 사용되어지는데
		  	조건식이 참 이라면 변수에 값1을 대입해주고,
		  	만약에 조건식이 거짓이라면 변수에 값2를 대입해준다.
		 */
		System.out.println("\n==== 9.삼항연산자 ====");
		int num1=50, num2=60;
		int num3=(num1 > num2)?num1:num2;
		System.out.println("num3 =>" + num3);
		// num3 => 60
	}

}
